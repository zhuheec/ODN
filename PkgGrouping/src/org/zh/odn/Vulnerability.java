package org.zh.odn;

import java.util.LinkedList;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.tg.TinkerGraph;

public class Vulnerability {

	private static final String START_TAG = "B_0";
	private static final String END_TAG = "E_0";
	private static final String NAME_TAG = "className";
	
	private LinkedList<LinkedList<Vertex>> allPaths;
	private Graph pathTree;
	private int pathCount = 0;
	
	public Vulnerability() {
		allPaths = new LinkedList<LinkedList<Vertex>>();
		pathTree = new TinkerGraph();
		Vertex start = pathTree.addVertex(START_TAG);
		start.setProperty(NAME_TAG, "B");
	}
	
	private <T> LinkedList<T> toLinkedList(Iterable<T> iterable) {
		LinkedList<T> list = new LinkedList<T>();
	    for (T t : iterable) {
	        list.add(t);
	    }
	    return list;
	}

	private void depthFirst(Graph graph, LinkedList<Vertex> visited) {
		LinkedList<Vertex> nodes = toLinkedList(visited.getLast().getVertices(Direction.BOTH));
		// examine adjacent nodes
		for (Vertex node : nodes) {
			if (visited.contains(node)) {
				continue;
			}
			if (node.getId().equals(END_TAG)) {
				visited.add(node);
				addPath(new LinkedList<Vertex>(visited));
				visited.removeLast();
				break;
			}
		}
		// in breadth-first, recursion needs to come after visiting adjacent nodes
		for (Vertex node : nodes) {
			if (visited.contains(node) || 
					node.getId().equals(END_TAG)) {
				continue;
			}
			visited.addLast(node);
			depthFirst(graph, visited);
			visited.removeLast();
		}
	}
	
	private void addPath(LinkedList<Vertex> visited) {
		allPaths.add(visited);
		pathCount++;
		Vertex treeNode = pathTree.getVertex(START_TAG);
		int index = 1;
		while(index < visited.size()) {
			Vertex current = visited.get(index++);
			boolean isChild = false;
			for(Vertex neighbor : treeNode.getVertices(Direction.OUT)) {
				if(neighbor.getProperty(NAME_TAG).equals(current.getProperty(NAME_TAG))) {
					isChild = true;
					treeNode = neighbor;
					break;
				}
			}
			if(!isChild) {
				Vertex newNode = pathTree.addVertex(current.getProperty(NAME_TAG).toString()
						+ "_" + pathCount);
				newNode.setProperty(NAME_TAG, current.getProperty(NAME_TAG));
				pathTree.addEdge(treeNode.getId() + "--" + newNode.getId(), 
						treeNode, newNode, "");
				treeNode = newNode;
			}
		}
	}
	
	private void printTree(Vertex vertex) {
		System.out.print("The children of [" + vertex.getId() + "] is: ");
		for(Vertex v : vertex.getVertices(Direction.OUT)) {
			System.out.print(v.getId() + " ");
		}
		System.out.println();
		for(Vertex v : vertex.getVertices(Direction.OUT)) {
			printTree(v);
		}
	}

	public void printPath() {
		for(LinkedList<Vertex> path : allPaths) {
			for (Vertex node : path) {
				System.out.print(node.getId());
				if(node != path.getLast()) {
					System.out.print("-->");
				}
			}
			System.out.println();
		}
	}

	public static void main(String[] args) {
		// this graph is directional
		Graph graph = new TinkerGraph();
		Vertex va = graph.addVertex("A_0");
		va.setProperty(NAME_TAG, "A");
		Vertex vb = graph.addVertex("B_0");
		vb.setProperty(NAME_TAG, "B");
		Vertex vc = graph.addVertex("C_0");
		vc.setProperty(NAME_TAG, "C");
		Vertex vd = graph.addVertex("D_0");
		vd.setProperty(NAME_TAG, "D");
		Vertex ve = graph.addVertex("E_0");
		ve.setProperty(NAME_TAG, "E");
		Vertex vf = graph.addVertex("F_0");
		vf.setProperty(NAME_TAG, "F");
		
		graph.addEdge("A-B", va, vb, "A-B");
		graph.addEdge("A-C", va, vc, "A-C");
		graph.addEdge("B-D", vb, vd, "B-D");
		graph.addEdge("B-E", vb, ve, "B-E");
		graph.addEdge("B-F", vb, vf, "B-F");
		graph.addEdge("C-E", vc, ve, "C-E");
		graph.addEdge("C-F", vc, vf, "C-F");
		graph.addEdge("E-F", ve, vf, "E-F");

		LinkedList<Vertex> visited = new LinkedList<Vertex>();
		visited.add(vb);
		
		Vulnerability vul = new Vulnerability();
		vul.depthFirst(graph, visited);
		vul.printTree(vul.pathTree.getVertex(START_TAG));		
	}
}
