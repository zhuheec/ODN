package org.zh.odn;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.tg.TinkerGraph;

public class Vulnerability {

	private static final String NAME_TAG = "className";
	
	private Graph graph = null;
	private String startTag = "";
	private String endTag = "";
	
	
	private LinkedList<LinkedList<Vertex>> allPaths;
	private Graph pathTree;
	private int pathCount = 0;
	
	public Vulnerability(Graph graph, Vertex startNode, Vertex endNode) {
		allPaths = new LinkedList<LinkedList<Vertex>>();
		pathTree = new TinkerGraph();
		this.startTag = startNode.getId().toString();
		this.endTag = endNode.getId().toString();
		this.graph = graph;
		LinkedList<Vertex> visited = new LinkedList<Vertex>();
		visited.add(startNode);
		depthFirst(visited);
	}
	
	/**
	 * Convert an iterable object to a linked list
	 * @param iterable An iterable object
	 * @return A linked list
	 */
	private <T> LinkedList<T> toLinkedList(Iterable<T> iterable) {
		LinkedList<T> list = new LinkedList<T>();
	    for (T t : iterable) {
	        list.add(t);
	    }
	    return list;
	}

	/**
	 * Perform depth-first search for paths from source to destination
	 * @param visited The list of currently visited nodes
	 */
	private void depthFirst(LinkedList<Vertex> visited) {
		// get all neighbors of the last node in current path
		LinkedList<Vertex> nodes = toLinkedList(visited.getLast().getVertices(Direction.BOTH));
		// examine adjacent nodes
		for (Vertex node : nodes) {
			// do not re-visit a node
			if (visited.contains(node)) {
				continue;
			}
			// add path to path list if reached the end node
			if (node.getId().equals(endTag)) {
				visited.add(node);
				addPath(new LinkedList<Vertex>(visited));
				visited.removeLast();
				break;
			}
		}
		// recursively call depth-first algorithm
		for (Vertex node : nodes) {
			if (visited.contains(node) || 
					node.getId().equals(endTag)) {
				continue;
			}
			visited.addLast(node);
			depthFirst(visited);
			visited.removeLast();
		}
	}
	
	/**
	 * Add path to path list, and add it to the path tree
	 * @param visited An applicable path
	 */
	private void addPath(LinkedList<Vertex> visited) {
		allPaths.add(visited); // add path to path list
		pathCount++; // unique ID for current path, used to differentiate vertex 
		Vertex treeNode = pathTree.getVertex(startTag); // root node for path tree
		int index = 1;
		while(index < visited.size()) {
			Vertex current = visited.get(index); 
			boolean isChild = false;
			for(Vertex neighbor : treeNode.getVertices(Direction.OUT)) {
				// check if current node exists in the tree path
				if(neighbor.getProperty(NAME_TAG).equals(current.getProperty(NAME_TAG))) {
					isChild = true;
					treeNode = neighbor;
					break;
				}
			}
			if(!isChild) {
				Vertex newNode = pathTree.addVertex(current.getProperty(NAME_TAG).toString()
						+ "_" + pathCount);
				newNode.setProperty(NAME_TAG, current.getProperty(NAME_TAG));
				pathTree.addEdge(treeNode.getId() + "--" + newNode.getId(), 
						treeNode, newNode, "");
				treeNode = newNode;
				visited.set(index, newNode);
			}
			index++;
		}
	}
	
	private void printTree(Vertex vertex) {
		System.out.print("The children of [" + vertex.getId() + "] is: ");
		for(Vertex v : vertex.getVertices(Direction.OUT)) {
			System.out.print(v.getId() + " ");
		}
		System.out.println();
		for(Vertex v : vertex.getVertices(Direction.OUT)) {
			printTree(v);
		}
	}
	
	private void listConditionalPaths() {
		HashSet<String> failedEdges = new HashSet<String>();
		HashMap<LinkedList<Vertex>, HashSet<String>> conditionsMap = 
				new HashMap<LinkedList<Vertex>, HashSet<String>>();
		LinkedList<Vertex> prevPath = null;
		for(LinkedList<Vertex> path : allPaths) {
			failedEdges.add(getFailedEdge(prevPath, path));
			// merge failed edges
			merge(failedEdges);
			conditionsMap.put(new LinkedList<Vertex>(path), new HashSet<String>(failedEdges));
		}
	}
	
	private void merge(HashSet<String> failedEdges) {
		
	}
	
	private String getFailedEdge(LinkedList<Vertex> prev, LinkedList<Vertex> curr) {
		String ret = null;
		if(prev != null) {
			int idx = prev.size() > curr.size() ? curr.size() : prev.size();
			Vertex prevOverlapNode = null;
			for(int i = 0; i < idx; i++) {
				if(prev.get(i).getId().equals(curr.get(i).getId())) {
					prevOverlapNode = prev.get(i);
				} else {
					ret = prev.get(i).getProperty(NAME_TAG) + "-->" +
							prev.get(i+1).getProperty(NAME_TAG);
				}
			}	
		}
		return ret;
	}

	public void printPath() {
		for(LinkedList<Vertex> path : allPaths) {
			for (Vertex node : path) {
				System.out.print(node.getId());
				if(node != path.getLast()) {
					System.out.print("-->");
				}
			}
			System.out.println();
		}
	}

	public static void main(String[] args) {
		// this graph is directional
		Graph graph = new TinkerGraph();
		Vertex va = graph.addVertex("A_0");
		va.setProperty(NAME_TAG, "A");
		Vertex vb = graph.addVertex("B_0");
		vb.setProperty(NAME_TAG, "B");
		Vertex vc = graph.addVertex("C_0");
		vc.setProperty(NAME_TAG, "C");
		Vertex vd = graph.addVertex("D_0");
		vd.setProperty(NAME_TAG, "D");
		Vertex ve = graph.addVertex("E_0");
		ve.setProperty(NAME_TAG, "E");
		Vertex vf = graph.addVertex("F_0");
		vf.setProperty(NAME_TAG, "F");
		
		graph.addEdge("A-B", va, vb, "A-B");
		graph.addEdge("A-C", va, vc, "A-C");
		graph.addEdge("B-D", vb, vd, "B-D");
		graph.addEdge("B-E", vb, ve, "B-E");
		graph.addEdge("B-F", vb, vf, "B-F");
		graph.addEdge("C-E", vc, ve, "C-E");
		graph.addEdge("C-F", vc, vf, "C-F");
		graph.addEdge("E-F", ve, vf, "E-F");

		
		//vul.printTree(vul.pathTree.getVertex(START_TAG));		
	}
}
