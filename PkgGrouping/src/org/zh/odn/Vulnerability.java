package org.zh.odn;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.impls.tg.TinkerGraph;

public class Vulnerability {

	private static final String NAME_TAG = "className";
	
	private Graph graph = null;
	private String startTag = "";
	private String endTag = "";
	
	
	private LinkedList<LinkedList<Vertex>> allPaths;
	private Graph pathTree;
	private int pathCount = 0;
	
	/**
	 * Create an instance for vulnerability calculation between two nodes.
	 * @param graph The graph where the two nodes are
	 * @param startNode The node to start
	 * @param endNode The node to end
	 */
	public Vulnerability(Graph graph, Vertex startNode, Vertex endNode) {
		allPaths = new LinkedList<LinkedList<Vertex>>();
		pathTree = new TinkerGraph();
		this.startTag = startNode.getId().toString();
		this.endTag = endNode.getId().toString();
		this.graph = graph;
		LinkedList<Vertex> visited = new LinkedList<Vertex>();
		visited.add(startNode);
		depthFirst(visited);
	}
	
	/**
	 * Convert an iterable object to a linked list
	 * @param iterable An iterable object
	 * @return A linked list
	 */
	private <T> LinkedList<T> toLinkedList(Iterable<T> iterable) {
		LinkedList<T> list = new LinkedList<T>();
	    for (T t : iterable) {
	        list.add(t);
	    }
	    return list;
	}

	/**
	 * Perform depth-first search for paths from source to destination
	 * @param visited The list of currently visited nodes
	 */
	private void depthFirst(LinkedList<Vertex> visited) {
		// get all neighbors of the last node in current path
		LinkedList<Vertex> nodes = toLinkedList(visited.getLast().getVertices(Direction.BOTH));
		// examine adjacent nodes
		for (Vertex node : nodes) {
			// do not re-visit a node
			if (visited.contains(node)) {
				continue;
			}
			// add path to path list if reached the end node
			if (node.getId().equals(endTag)) {
				visited.add(node);
				addPath(new LinkedList<Vertex>(visited));
				visited.removeLast();
				break;
			}
		}
		// recursively call depth-first algorithm
		for (Vertex node : nodes) {
			if (visited.contains(node) || 
					node.getId().equals(endTag)) {
				continue;
			}
			visited.addLast(node);
			depthFirst(visited);
			visited.removeLast();
		}
	}
	
	/**
	 * Add path to path list, and add it to the path tree
	 * @param visited An applicable path
	 */
	private void addPath(LinkedList<Vertex> visited) {
		allPaths.add(visited); // add path to path list
		pathCount++; // unique ID for current path, used to differentiate vertex 
		Vertex treeNode = pathTree.getVertex(startTag); // root node for path tree
		int index = 1;
		while(index < visited.size()) {
			Vertex current = visited.get(index); 
			boolean isChild = false;
			for(Vertex neighbor : treeNode.getVertices(Direction.OUT)) {
				// check if current node exists in the tree path
				if(neighbor.getProperty(NAME_TAG).equals(current.getProperty(NAME_TAG))) {
					isChild = true;
					treeNode = neighbor;
					break;
				}
			}
			if(!isChild) {
				Vertex newNode = pathTree.addVertex(current.getProperty(NAME_TAG).toString()
						+ "_" + pathCount);
				newNode.setProperty(NAME_TAG, current.getProperty(NAME_TAG));
				pathTree.addEdge(treeNode.getId() + "--" + newNode.getId(), 
						treeNode, newNode, "");
				treeNode = newNode;
				visited.set(index, newNode);
			}
			index++;
		}
	}
	
	/**
	 * Print the path tree starting from a vertex
	 * to the end node of this instance
	 * @param vertex The vertext to start
	 */
	public void printTree(Vertex vertex) {
		System.out.print("The children of [" + vertex.getId() + "] is: ");
		for(Vertex v : vertex.getVertices(Direction.OUT)) {
			System.out.print(v.getId() + " ");
		}
		System.out.println();
		for(Vertex v : vertex.getVertices(Direction.OUT)) {
			printTree(v);
		}
	}
	
	/**
	 * List all paths with conditions for each to be chosen.
	 * We do this to make propagation vulnerability for each
	 * path independent, and to make it easier for overall
	 * propagation vulnerability calculation.
	 */
	public HashMap<LinkedList<Vertex>, HashSet<String[]>> listPathsWithConditions() {
		LinkedList<String[]> failedEdges = new LinkedList<String[]>();
		HashMap<LinkedList<Vertex>, HashSet<String[]>> conditionsMap = 
				new HashMap<LinkedList<Vertex>, HashSet<String[]>>();
		LinkedList<Vertex> prevPath = null;
		for(LinkedList<Vertex> path : allPaths) {
			// add and merge the new failed edge
			addAndMerge(failedEdges, getFailedEdge(prevPath, path));
			conditionsMap.put(new LinkedList<Vertex>(path), new HashSet<String[]>(failedEdges));
			prevPath = path;
		}
		return conditionsMap;
	}
	
	/**
	 * Check if the edge to add can cover previous edges in the list.
	 * If so, remove previous duplicate edges.
	 * At last, add the edge.
	 * @param failedEdges The linked list for existing failed edges
	 * @param edge The edge to add
	 */
	private void addAndMerge(LinkedList<String[]> failedEdges, String[] edge) {
		Vertex subTreeStart = pathTree.getVertex(edge[1]);
		LinkedList<String[]> edgesToRemove = new LinkedList<String[]>();
		for(String[] currentEdge : failedEdges) {
			if(isSubTreeContainsEdge(subTreeStart, currentEdge)) {
				edgesToRemove.add(currentEdge);
			}
		}
		failedEdges.removeAll(edgesToRemove);
		failedEdges.add(edge);
	}
	
	/**
	 * Check if the sub tree with the root start (fist parameter) contains
	 * the specified edge (second parameter)
	 * @param start The start node of the sub tree
	 * @param edge The edge to check
	 * @return Whether or not the sub tree contains the tartget edge.
	 */
	private boolean isSubTreeContainsEdge(Vertex start, String[] edge) {
		for(Vertex v : start.getVertices(Direction.OUT)) {
			if(v.getId().equals(edge[0])) {
				for(Vertex v2 : v.getVertices(Direction.OUT)) {
					if(v2.getId().equals(edge[1])) {
						return true;
					}
				}
			}
			return isSubTreeContainsEdge(v, edge);
		}
		return false;
	}
	
	private String[] getFailedEdge(LinkedList<Vertex> prev, LinkedList<Vertex> curr) {
		String[] ret = null;
		if(prev != null) {
			int idx = prev.size() > curr.size() ? curr.size() : prev.size();
			for(int i = 0; i < idx; i++) {
				if(!prev.get(i).getId().equals(curr.get(i).getId())) {
					ret = new String[] { prev.get(i).getId().toString(),
							prev.get(i+1).getId().toString() };
				}
			}	
		}
		return ret;
	}

	public void printPath() {
		for(LinkedList<Vertex> path : allPaths) {
			for (Vertex node : path) {
				System.out.print(node.getId());
				if(node != path.getLast()) {
					System.out.print("-->");
				}
			}
			System.out.println();
		}
	}

	public static void main(String[] args) {
		// this graph is directional
		Graph graph = new TinkerGraph();
		Vertex va = graph.addVertex("A_0");
		va.setProperty(NAME_TAG, "A");
		Vertex vb = graph.addVertex("B_0");
		vb.setProperty(NAME_TAG, "B");
		Vertex vc = graph.addVertex("C_0");
		vc.setProperty(NAME_TAG, "C");
		Vertex vd = graph.addVertex("D_0");
		vd.setProperty(NAME_TAG, "D");
		Vertex ve = graph.addVertex("E_0");
		ve.setProperty(NAME_TAG, "E");
		Vertex vf = graph.addVertex("F_0");
		vf.setProperty(NAME_TAG, "F");
		
		graph.addEdge("A-B", va, vb, "A-B");
		graph.addEdge("A-C", va, vc, "A-C");
		graph.addEdge("B-D", vb, vd, "B-D");
		graph.addEdge("B-E", vb, ve, "B-E");
		graph.addEdge("B-F", vb, vf, "B-F");
		graph.addEdge("C-E", vc, ve, "C-E");
		graph.addEdge("C-F", vc, vf, "C-F");
		graph.addEdge("E-F", ve, vf, "E-F");

		
		//vul.printTree(vul.pathTree.getVertex(START_TAG));		
	}
}
